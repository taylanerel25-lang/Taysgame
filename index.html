<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Tay‚Äôs Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />

  <style>
    :root {
      --bg: #87ceeb;                 /* default sky */
      --panel: rgba(255,255,255,0.92);
      --panel-dark: rgba(0,0,0,0.65);
      --text: #1d1d1f;
      --shadow: 0 10px 40px rgba(0,0,0,0.35);
    }

    html, body {
      height: 100%;
      margin: 0;
      background: #111;
      color: var(--text);
      font-family: ui-rounded, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans";
      overscroll-behavior: none;
    }

    .wrap {
      position: fixed; inset: 0;
      display: grid; place-items: center;
      padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    }

    canvas {
      background: var(--bg);
      box-shadow: var(--shadow);
      border-radius: 16px;
      image-rendering: pixelated;
      touch-action: none;
    }

    /* HUD */
    .hud { position: fixed; inset: 0; pointer-events: none; display: grid; place-items: center; font-weight: 700; letter-spacing: .5px; user-select: none; }
    .topbar {
      position: fixed; top: 10px; left: 50%; transform: translateX(-50%);
      display: flex; gap: 8px; align-items: center; pointer-events: auto; flex-wrap: wrap; justify-content: center;
      z-index: 3;
    }
    .btn, .toggle { appearance: none; border: 0; background: var(--panel); color: #111; padding: 8px 12px; border-radius: 999px; font-weight: 700; box-shadow: 0 2px 8px rgba(0,0,0,.15); cursor: pointer; }
    .toggle { display: flex; gap: 6px; align-items: center; }
    .btn:focus, .toggle:focus { outline: 3px solid #000; outline-offset: 2px; }

    .score { position: fixed; top: 18px; right: 14px; font-size: 28px; color: #fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); pointer-events: none; }
    .best  { position: fixed; top: 18px; left: 14px;  font-size: 16px; color: #fff; text-shadow: 0 2px 0 rgba(0,0,0,.6); pointer-events: none; }

    /* Splash layout (clean + no overlap) */
    .splash {
      position: absolute; inset: 0;
      display: grid; grid-template-rows: 1fr auto 1fr;
      pointer-events: none; color: #fff; text-shadow: 0 2px 0 rgba(0,0,0,.5);
      z-index: 2;
    }
    .splash .titleWrap {
      display: grid; place-items: center;
      align-self: start; margin-top: 72px;   /* clears topbar/buttons */
    }
    .splash .title { font-size: 36px; line-height: 1.05; text-align: center; }
    .splash .subtitle { font-size: 18px; text-align: center; opacity: .95; margin-top: 6px; }

    /* Compact leaderboard card on splash, pinned near bottom of canvas */
    .splash .lb-card {
      pointer-events: auto;
      width: min(86vw, 320px);
      justify-self: center;
      align-self: end;
      margin-bottom: 86px;                 /* above ground tiles */
      background: rgba(0,0,0,.7);
      color: #fff; border-radius: 18px; padding: 12px 14px;
      box-shadow: 0 10px 24px rgba(0,0,0,.35);
    }
    .splash .lb-card h3 { margin: 2px 0 8px; font-size: 18px; text-align: center; }
    .splash .lb-row {
      display: flex; justify-content: space-between; font-size: 14px; padding: 3px 0;
    }
    .splash .lb-empty { opacity: .9; text-align: center; padding: 6px 0; font-size: 14px; }

    /* Game over panel */
    .panel { min-width: 280px; max-width: 90vw; background: var(--panel); color: #111; border-radius: 18px; padding: 16px; box-shadow: 0 8px 30px rgba(0,0,0,.25); pointer-events: auto; transform: translateY(8px); }
    .panel h2 { margin: 0 0 8px 0; font-size: 22px; text-align: center; }
    .panel .row { display: flex; justify-content: space-between; align-items: center; font-size: 18px; padding: 6px 0; }
    .panel .actions { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-top: 12px; }
    .pill { display: inline-flex; align-items: center; gap: 6px; background: rgba(0,0,0,.08); padding: 4px 10px; border-radius: 999px; font-size: 14px; }

    /* Leaderboard in Game Over */
    #leaderboardListGO h3 { margin: 8px 0 6px; text-align: center; }
    #leaderboardListGO .row { font-size: 16px; }

    .sr-only { position: absolute!important; width: 1px; height: 1px; padding: 0; margin: -1px; overflow: hidden; clip: rect(0,0,0,0); white-space: nowrap; border: 0; }
    .toast { position: fixed; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,.85); color: #fff; padding: 8px 12px; border-radius: 10px; font-size: 14px; pointer-events: none; opacity: 0; transition: opacity .25s ease, transform .25s ease; }
    .toast.show { opacity: 1; transform: translate(-50%, -6px); }

    .high-contrast canvas { outline: 4px solid #000; }
    .high-contrast .btn, .high-contrast .toggle, .high-contrast .panel { border: 3px solid #000; }

    .paused-badge { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; color: #fff; font-size: 26px; text-shadow: 0 2px 0 rgba(0,0,0,.6); z-index: 3; }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="game" width="360" height="640" aria-label="Tay‚Äôs Game canvas"></canvas>
  </div>

  <div class="hud" aria-hidden="true">
    <div id="topbar" class="topbar">
      <button id="muteBtn" class="btn" aria-pressed="false" aria-label="Toggle sound">üîä Sound</button>
      <label class="toggle"><input type="checkbox" id="casualToggle"> Casual</label>
      <label class="toggle"><input type="checkbox" id="hcToggle"> High contrast</label>
      <label class="toggle"><input type="checkbox" id="rmToggle"> Reduced motion</label>
      <button id="pauseBtn" class="btn" aria-label="Pause (P)">‚è∏Ô∏è Pause</button>
    </div>

    <div id="scoreHud" class="score">0</div>
    <div id="bestHud" class="best">Highest: 0</div>

    <!-- Splash: tidy, no overlap; leaderboard card near bottom -->
    <div id="splash" class="splash">
      <div class="titleWrap">
        <div class="title">Tay‚Äôs Game ‚ù§Ô∏è</div>
        <div class="subtitle">Tap / Click / Space to start</div>
        <div class="subtitle" style="margin-top:6px; font-size:14px; opacity:.95;">Avoid the pipes. Good luck!</div>
      </div>

      <div></div> <!-- spacer -->

      <div class="lb-card" id="splashLB">
        <h3>üèÜ Leaderboard</h3>
        <div id="leaderboardListSplash">
          <div class="lb-empty">Loading...</div>
        </div>
      </div>
    </div>

    <div id="pausedBadge" class="paused-badge" style="display:none;">Paused</div>
  </div>

  <!-- Game Over -->
  <div id="gameOver" class="hud" style="display:none;">
    <div class="panel" role="dialog" aria-modal="true" aria-labelledby="overTitle">
      <h2 id="overTitle">Game Over</h2>
      <div class="row"><span>Your Score</span><strong id="scoreNow">0</strong></div>
      <div class="row"><span>Highest Score</span><span><strong id="bestNow">0</strong> <span id="medal" class="pill" aria-label="medal" style="display:none;">ü•â Bronze</span></span></div>
      <div class="actions">
        <button id="againBtn" class="btn">Play Again</button>
        <button id="shareBtn" class="btn">Share</button>
      </div>

      <!-- Leaderboard (Game Over) -->
      <div id="leaderboardListGO" style="margin-top:12px;">
        <h3>üèÜ Leaderboard</h3>
        <div class="row" style="justify-content:center; opacity:.8;">Loading...</div>
      </div>
    </div>
  </div>

  <div id="aria" class="sr-only" aria-live="polite"></div>
  <div id="toast" class="toast" role="status"></div>

  <!-- ===== Game Code ===== -->
  <script>
  (() => {
    'use strict';

    const CFG = {
      canvas: { width: 360, height: 640 },
      physics: { gravity: 1800, flapImpulse: -420, maxFallSpeed: 900 },
      world: { speedStart: 180, speedEnd: 240, speedEndScore: 30 },
      pipes: {
        gapStart: 160, gapEnd: 135, gapEndScore: 20,
        spawnStart: 1.2, spawnEnd: 0.95, spawnEndScore: 25,
        minGapCenterY: 120, maxGapCenterYPaddingBottom: 120, width: 64
      },
      bird: { size: { w: 34, h: 24 }, hitboxRadius: 12 },
      ground: { height: 112 },
      scorePopup: { dy: 40, duration: 0.6 },
      birdIdleBobPx: 4
    };

    const DPR = Math.min(window.devicePixelRatio || 1, 3);

    /* DOM */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const splashEl = document.getElementById('splash');
    const hudScore = document.getElementById('scoreHud');
    const overPanel = document.getElementById('gameOver');
    const scoreNow = document.getElementById('scoreNow');
    const bestNow  = document.getElementById('bestNow');
    const medalEl  = document.getElementById('medal');
    const muteBtn  = document.getElementById('muteBtn');
    const casualToggle = document.getElementById('casualToggle');
    const hcToggle     = document.getElementById('hcToggle');
    const rmToggle     = document.getElementById('rmToggle');
    const pauseBtn     = document.getElementById('pauseBtn');
    const pausedBadge  = document.getElementById('pausedBadge');
    const ariaLive = document.getElementById('aria');
    const toast = document.getElementById('toast');
    const topbar = document.getElementById('topbar');

    /* STATE */
    const W = CFG.canvas.width, H = CFG.canvas.height;
    const groundY = H - CFG.ground.height;

    let state = 'ready';    // 'ready' | 'running' | 'dead'
    let paused = false;
    let worldTime = 0;
    let spawnTimer = 0;
    let lastMs = performance.now();

    const storage = {
      best: Number(localStorage.getItem('sb_best') || 0),
      muted: localStorage.getItem('sb_muted') === '1',
      reduced: localStorage.getItem('sb_reduced') === '1',
      highContrast: localStorage.getItem('sb_highcontrast') === '1',
      casual: localStorage.getItem('sb_casual') === '1'
    };
    if (storage.muted)       muteBtn.setAttribute('aria-pressed', 'true'), muteBtn.textContent = 'üîá Muted';
    if (storage.highContrast)document.body.classList.add('high-contrast'), hcToggle.checked = true;
    if (storage.reduced)     rmToggle.checked = true;
    if (storage.casual)      casualToggle.checked = true;

    const BIRD_X = Math.round(W * 0.28);
    let bird = { x: BIRD_X, y: H * 0.5, vy: 0, rot: 0, frame: 0, frameTimer: 0 };

    const pipes = [];
    const pops  = [];
    const clouds = [
      { x: 40,  y: 100, s: 0.3 },
      { x: 240, y: 60,  s: 0.25 },
      { x: 170, y: 140, s: 0.22 }
    ];

    let score = 0;
    window.score = 0; // make current score visible to Firebase block

    const medalFor = (s) =>
      s >= 50 ? ['üèÜ Platinum', '#e5e4e2'] :
      s >= 30 ? ['ü•á Gold',     '#f7c32e'] :
      s >= 20 ? ['ü•à Silver',   '#c0c0c0'] :
      s >= 10 ? ['ü•â Bronze',   '#cd7f32'] : null;

    /* Stages */
    const stageSkies = ['#87ceeb', '#ffa366', '#9966cc', '#1a1a2e', '#ffe680'];
    const stagePipes = ['#2fbf59', '#ff9933', '#aa66cc', '#e74c3c', '#ffcc00'];
    let lastStage = -1;
    const currentStage = () => Math.min(Math.floor(score / 10), stageSkies.length - 1);
    const onStageChange = () => showToast(`Stage ${currentStage() + 1}!`);

    /* Audio */
    let audioCtx = null;
    const ensureAudio = () => { if (!audioCtx) { try { audioCtx = new (window.AudioContext || window.webkitAudioContext)(); } catch {} } };
    const beep = (type, freq, dur, vol=0.2) => {
      if (!audioCtx || storage.muted) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = type; o.frequency.value = freq; g.gain.value = vol;
      o.connect(g).connect(audioCtx.destination);
      const t = audioCtx.currentTime; o.start(t);
      g.gain.exponentialRampToValueAtTime(0.0001, t + dur*0.9); o.stop(t + dur);
    };
    const sfx = {
      flap: () => beep('square',   600, 0.08, 0.15),
      point:()=> beep('triangle',  880, 0.07, 0.18),
      hit:  () => beep('sawtooth', 120, 0.15, 0.22),
      die:  () => beep('sine',      80, 0.35, 0.25),
      swoosh:()=> beep('triangle', 300, 0.10, 0.12)
    };

    /* Helpers */
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const lerp  = (a, b, t) => a + (b - a) * t;
    const easeT = (s, end) => clamp(s / end, 0, 1);
    const pipeGap = () => (window.dynamicPipeGap ?? lerp(CFG.pipes.gapStart, CFG.pipes.gapEnd, easeT(score, CFG.pipes.gapEndScore)));
    const spawnInterval = () => lerp(CFG.pipes.spawnStart, CFG.pipes.spawnEnd, easeT(score, CFG.pipes.spawnEndScore));
    const speedBase = () => {
      const base = lerp(CFG.world.speedStart, CFG.world.speedEnd, easeT(score, CFG.world.speedEndScore));
      return storage.casual ? Math.max(150, base - 30) : base;
    };
    const showToast = (msg) => { toast.textContent = msg; toast.classList.add('show'); clearTimeout(showToast._t); showToast._t = setTimeout(() => toast.classList.remove('show'), 1200); };
    const announce  = (msg) => { ariaLive.textContent = ''; setTimeout(() => ariaLive.textContent = msg, 30); };

    function resetGame() {
      score = 0; hudScore.textContent = '0'; worldTime = 0; spawnTimer = -0.5;
      pipes.length = 0; pops.length = 0;
      bird = { x: BIRD_X, y: H*0.5, vy: 0, rot: 0, frame: 0, frameTimer: 0 };
      sfx.swoosh();
      lastStage = -1;
      document.getElementById('bestHud').textContent = `Highest: ${storage.best}`;
    }

    /* DPR / Resize */
    function fitCanvas() {
      const aspect = W / H;
      const vw = window.innerWidth, vh = window.innerHeight;
      let cssW, cssH;
      if (vw / vh < aspect) { cssW = Math.min(vw, W*2.5); cssH = Math.round(cssW / aspect); }
      else                  { cssH = Math.min(vh, H*2.5); cssW = Math.round(cssH * aspect); }
      canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
      canvas.width = Math.round(W * DPR); canvas.height = Math.round(H * DPR);
      ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR, DPR); ctx.imageSmoothingEnabled = false;
    }
    window.addEventListener('resize', fitCanvas, { passive: true }); fitCanvas();

    /* UI show/hide */
    function refreshUI() {
      const show = (state === 'ready') || (state === 'running' && paused);
      topbar.style.display = show ? '' : 'none';
    }

    /* Input */
    const flap = () => {
      if (state === 'dead') return;
      ensureAudio();
      if (state === 'ready') {
        state = 'running';
        announce('Game started');
        splashEl.style.display = 'none';
        refreshUI();
      }
      if (paused) return;
      bird.vy = CFG.physics.flapImpulse; sfx.flap();
    };
    canvas.addEventListener('mousedown', e => { e.preventDefault(); flap(); });
    canvas.addEventListener('touchstart', e => { e.preventDefault(); flap(); }, { passive: false });
    window.addEventListener('keydown', e => {
      const k = e.key.toLowerCase();
      if ([' ', 'w', 'arrowup'].includes(k)) { e.preventDefault(); flap(); }
      if (k === 'p') togglePause();
    }, { passive: false });
    pauseBtn.addEventListener('click', () => togglePause());

    document.addEventListener('visibilitychange', () => { if (document.hidden && state === 'running') setPause(true); });
    function setPause(p) { if (state !== 'running') return; paused = p; pausedBadge.style.display = p ? '' : 'none'; announce(p?'Paused':'Resumed'); refreshUI(); }
    function togglePause() { setPause(!paused); }

    /* UI toggles */
    muteBtn.addEventListener('click', () => {
      storage.muted = !storage.muted; localStorage.setItem('sb_muted', storage.muted ? '1' : '0');
      muteBtn.setAttribute('aria-pressed', storage.muted?'true':'false');
      muteBtn.textContent = storage.muted ? 'üîá Muted' : 'üîä Sound';
    });
    hcToggle.addEventListener('change', () => { storage.highContrast = hcToggle.checked; localStorage.setItem('sb_highcontrast', storage.highContrast?'1':'0'); document.body.classList.toggle('high-contrast', storage.highContrast); });
    rmToggle.addEventListener('change', () => { storage.reduced = rmToggle.checked; localStorage.setItem('sb_reduced', storage.reduced?'1':'0'); });
    casualToggle.addEventListener('change', () => { storage.casual = casualToggle.checked; localStorage.setItem('sb_casual', storage.casual?'1':'0'); showToast(storage.casual ? 'Casual Mode ON' : 'Casual Mode OFF'); });

    document.getElementById('againBtn').addEventListener('click', () => {
      overPanel.style.display = 'none'; splashEl.style.display = '';
      state = 'ready'; resetGame(); announce('Back to splash'); refreshUI();
    });
    document.getElementById('shareBtn').addEventListener('click', async () => {
      const text = `I scored ${scoreNow.textContent} in Tay‚Äôs Game! Can you beat me?`;
      try {
        if (navigator.share) await navigator.share({ text, title: 'Tay‚Äôs Game' });
        else { await navigator.clipboard.writeText(text); showToast('Copied to clipboard!'); }
      } catch {}
    });

    /* Game logic */
    function spawnPipe() {
      const gap = pipeGap();
      const padBottom = CFG.pipes.maxGapCenterYPaddingBottom;
      const minC = CFG.pipes.minGapCenterY;
      const maxCenter = (groundY - padBottom) - gap/2;
      const minCenter = minC + gap/2;
      const gapY = Math.round(lerp(minCenter, maxCenter, Math.random()));
      pipes.push({ x: W + 10, gapY, gap, w: CFG.pipes.width, scored: false });
    }

    function update(dt) {
      if (state !== 'running' || paused) return;
      const speed = speedBase();
      worldTime += dt; spawnTimer += dt;

      if (spawnTimer >= spawnInterval()) { spawnTimer = 0; spawnPipe(); }

      if (!storage.reduced) {
        for (const c of clouds) { c.x -= speed * c.s * dt; if (c.x < -80) c.x += W + 160; }
      }

      bird.vy += CFG.physics.gravity * dt;
      bird.vy = clamp(bird.vy, -9999, CFG.physics.maxFallSpeed);
      bird.y += bird.vy * dt; bird.y = clamp(bird.y, 2, H + 1000);

      const targetRot = bird.vy < 0 ? -25 * Math.PI/180 : Math.min(90 * Math.PI/180, bird.vy / CFG.physics.maxFallSpeed * (90*Math.PI/180));
      bird.rot = lerp(bird.rot, targetRot, 0.12);

      const animFps = bird.vy < 0 ? 8 : 4;
      bird.frameTimer += dt; if (bird.frameTimer >= 1/animFps) { bird.frame = (bird.frame + 1) % 3; bird.frameTimer = 0; }

      for (const p of pipes) {
        p.x -= speed * dt;
        const cx = p.x + p.w/2;
        if (!p.scored && cx < bird.x) {
          p.scored = true; score++; hudScore.textContent = String(score);
          window.score = score;
          if (score > storage.best) {
            storage.best = score;
            localStorage.setItem('sb_best', String(score));
            document.getElementById('bestHud').textContent = `Highest: ${storage.best}`;
          }
          pops.push({ x: cx, y: p.gapY, t: 0, duration: CFG.scorePopup.duration, text: '+1' });
          if (navigator.vibrate) navigator.vibrate(20);
          sfx.point(); announce(`Score ${score}`);

          const st = currentStage();
          if (st !== lastStage) { lastStage = st; onStageChange(); }
        }
      }
      while (pipes.length && pipes[0].x + pipes[0].w < -20) pipes.shift();

      // Collisions
      const r = CFG.bird.hitboxRadius;
      const circle = { x: bird.x + 2, y: bird.y, r };
      const penetrationNeeded = 0.2 * r;
      let hit = false;
      for (const p of pipes) {
        const topRect = { x: p.x, y: -10000, w: p.w, h: (p.gapY - p.gap/2) + 10000 };
        const botRect = { x: p.x, y: (p.gapY + p.gap/2), w: p.w, h: (groundY - (p.gapY + p.gap/2)) };
        if (circleRectDeepOverlap(circle, topRect, penetrationNeeded) ||
            circleRectDeepOverlap(circle, botRect, penetrationNeeded)) { hit = true; break; }
      }
      if (circle.y + circle.r >= groundY) { die(); return; }
      if (hit) { sfx.hit(); die(); }

      for (let i = pops.length-1; i >= 0; i--) {
        const pop = pops[i]; pop.t += dt; if (pop.t >= pop.duration) pops.splice(i,1);
      }
    }

    function circleRectDeepOverlap(circ, rect, needed) {
      const nx = clamp(circ.x, rect.x, rect.x + rect.w);
      const ny = clamp(circ.y, rect.y, rect.y + rect.h);
      const dx = circ.x - nx, dy = circ.y - ny;
      const dist = Math.hypot(dx, dy);
      const overlap = circ.r - dist;
      return overlap > needed;
    }

    function die() {
      state = 'dead'; refreshUI();
      paused = false; pausedBadge.style.display = 'none';
      if (navigator.vibrate) navigator.vibrate(80);
      sfx.die();

      const fallUntil = () => {
        const now = performance.now();
        const dt = Math.min((now - lastMs) / 1000, 1/30);
        lastMs = now;
        bird.vy += CFG.physics.gravity * dt;
        bird.vy = Math.min(bird.vy, CFG.physics.maxFallSpeed);
        bird.y += bird.vy * dt;
        bird.rot = lerp(bird.rot, 90*Math.PI/180, 0.12);
        render();
        if (bird.y + CFG.bird.hitboxRadius < groundY) requestAnimationFrame(fallUntil);
        else { bird.y = groundY - CFG.bird.hitboxRadius; setTimeout(showGameOver, 800); }
      };
      fallUntil();
    }

    function showGameOver() {
      scoreNow.textContent = String(score);
      if (score > storage.best) { storage.best = score; localStorage.setItem('sb_best', String(score)); }
      bestNow.textContent = String(storage.best);
      document.getElementById('bestHud').textContent = `Highest: ${storage.best}`;
      const m = medalFor(storage.best);
      if (m) { medalEl.style.display = ''; medalEl.textContent = m[0]; } else { medalEl.style.display = 'none'; }
      overPanel.style.display = '';
    }
    window.showGameOver = showGameOver;

    /* Render */
    function roundedRect(x,y,w,h,r) {
      ctx.beginPath();
      ctx.moveTo(x+r, y);
      ctx.arcTo(x+w, y, x+w, y+h, r);
      ctx.arcTo(x+w, y+h, x, y+h, r);
      ctx.arcTo(x, y+h, x, y, r);
      ctx.arcTo(x, y, x+w, y, r);
      ctx.closePath();
    }
    function drawClouds() {
      for (const c of clouds) {
        ctx.save(); ctx.translate(c.x, c.y);
        ctx.fillStyle = 'rgba(255,255,255,.9)';
        roundedRect(-20, -10, 40, 20, 8);
        roundedRect(5, -14, 30, 18, 8);
        roundedRect(-35, -8, 26, 16, 8);
        ctx.fill(); ctx.restore();
      }
    }
    function drawPipes() {
      const stage = currentStage();
      const color = stagePipes[stage];
      const dark  = 'rgba(0,0,0,.18)';
      for (const p of pipes) {
        const topH = p.gapY - p.gap/2;
        const botY = p.gapY + p.gap/2;
        const botH = groundY - botY;

        ctx.fillStyle = color; ctx.fillRect(p.x, 0, p.w, topH);
        ctx.fillStyle = dark;  ctx.fillRect(p.x - 4, topH - 16, p.w + 8, 16);

        ctx.fillStyle = color; ctx.fillRect(p.x, botY, p.w, botH);
        ctx.fillStyle = dark;  ctx.fillRect(p.x - 4, botY, p.w + 8, 16);

        ctx.fillStyle = 'rgba(0,0,0,.08)';
        ctx.fillRect(p.x + 6, 0, 3, topH); ctx.fillRect(p.x + 6, botY, 3, botH);
      }
    }
    function drawBird() {
      ctx.save();
      const w = CFG.bird.size.w, h = CFG.bird.size.h, r = CFG.bird.hitboxRadius;
      const idleBob = (state === 'ready' && !storage.reduced) ? Math.sin(worldTime * Math.PI * 2 * 2) * CFG.birdIdleBobPx : 0;
      ctx.translate(bird.x, bird.y + idleBob); ctx.rotate(bird.rot);

      ctx.fillStyle = '#ffd84a'; roundedRect(-w/2, -h/2, w, h, 6); ctx.fill();
      ctx.fillStyle = '#fff2b2'; roundedRect(-w*0.2, -h*0.15, w*0.8, h*0.7, 6); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(w*0.1, -h*0.1, 4, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(w*0.1+1, -h*0.1, 2, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#ff9a00'; ctx.beginPath(); ctx.moveTo(w*0.45, 0); ctx.lineTo(w*0.25, -3); ctx.lineTo(w*0.25, 3); ctx.closePath(); ctx.fill();

      const f = bird.frame; const wy = f===0?-2:f===1?0:2;
      ctx.save(); ctx.translate(-4, wy); ctx.fillStyle = '#f7bf3c'; roundedRect(-10, -6, 18, 12, 6); ctx.fill(); ctx.restore();

      if (document.body.classList.contains('high-contrast')) { ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.beginPath(); ctx.arc(2,0,r,0,Math.PI*2); ctx.stroke(); }
      ctx.restore();
    }
    function drawGround() {
      const speed = speedBase();
      const t = (worldTime * speed) % 48;
      const y = groundY;
      ctx.fillStyle = '#e6a65d'; ctx.fillRect(0, y, W, H - y);
      ctx.fillStyle = '#68c151'; ctx.fillRect(0, y-8, W, 8);
      ctx.fillStyle = 'rgba(0,0,0,.06)';
      for (let x=-t; x < W; x += 48) { ctx.fillRect(x, y+6, 24, 6); ctx.fillRect(x+24, y+16, 24, 6); }
    }

    function render() {
      const stage = currentStage();
      const sky = stageSkies[stage];
      canvas.style.background = sky;

      ctx.save();
      ctx.fillStyle = sky;
      ctx.fillRect(0,0,W,H);
      if (!storage.reduced) drawClouds();
      drawPipes();
      drawBird();
      drawGround();

      // Floating +1 pops
      for (const pop of pops) {
        const t = clamp(pop.t / pop.duration, 0, 1);
        const y = pop.y - t * CFG.scorePopup.dy;
        ctx.globalAlpha = 1 - t;
        ctx.fillStyle = '#fff'; ctx.font = 'bold 20px ui-rounded, system-ui, sans-serif'; ctx.textAlign = 'center';
        ctx.fillText(pop.text, pop.x, y);
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }

    function loop(now) {
      const dt = clamp((now - lastMs) / 1000, 0, 1/30);
      lastMs = now;
      if (state === 'ready') worldTime += dt;
      else if (state === 'running' && !paused) { worldTime += dt; update(dt); }
      render();
      requestAnimationFrame(loop);
    }

    function init() {
      resetGame();
      splashEl.style.display = '';
      hudScore.textContent = '0';
      document.getElementById('bestHud').textContent = `Highest: ${storage.best}`;
      bestNow.textContent = String(storage.best);
      overPanel.style.display = 'none';
      lastMs = performance.now();
      refreshUI();
      requestAnimationFrame(loop);
    }
    init();

  })();
  </script>

  <!-- ===== Firebase (single setup; leaderboard + remote config + analytics) ===== -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
    import { getDatabase, ref, push, set, get, onValue } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-database.js";
    import { getAnalytics, logEvent } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js";
    import { getRemoteConfig, fetchAndActivate, getValue } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-remote-config.js";

    // Your config (client-safe)
    const firebaseConfig = {
      apiKey: "AIzaSyCaLNISayGYJoiPdXPajHKFjCwvolkZQno",
      authDomain: "tay-s-game.firebaseapp.com",
      projectId: "tay-s-game",
      storageBucket: "tay-s-game.firebasestorage.app",
      messagingSenderId: "562563277539",
      appId: "1:562563277539:web:83f23217bde8543d19dbd6",
      measurementId: "G-LHR4F18RTJ",
      databaseURL: "https://tay-s-game-default-rtdb.firebaseio.com"
    };

    const app = initializeApp(firebaseConfig);
    const db  = getDatabase(app);
    const analytics = getAnalytics(app);
    const rc = getRemoteConfig(app);
    rc.settings.minimumFetchIntervalMillis = 60000;
    rc.defaultConfig = { current_pipe_gap_size: 160 };

    // Remote Config ‚Üí adaptive gap
    try {
      await fetchAndActivate(rc);
      const valNum = Number(getValue(rc, "current_pipe_gap_size")._value);
      if (!Number.isNaN(valNum) && valNum > 60 && valNum < 400) {
        window.dynamicPipeGap = valNum;
      }
    } catch {}

    // ----- Leaderboard logic -----
    function safeName(name){ return String(name || "Anonymous").trim(); }

    async function submitScore(name, score) {
      // raw history
      const entryRef = push(ref(db, "leaderboard"));
      await set(entryRef, { name: safeName(name), score, date: Date.now() });

      // bests/{playerKey}
      const key = safeName(name).toLowerCase().replace(/[.#$/\[\]\/]/g, "_");
      const bestRef = ref(db, "bests/" + key);
      const snap = await get(bestRef);
      const prev = snap.exists() ? Number(snap.val().bestScore || 0) : 0;
      if (score > prev) {
        await set(bestRef, { name: safeName(name), bestScore: score, updatedAt: Date.now() });
      }
    }

    // Attach to game over
    const originalShowGameOver = window.showGameOver;
    window.showGameOver = async (...args) => {
      if (typeof originalShowGameOver === "function") originalShowGameOver(...args);

      const scoreVal = Number(window.score || 0);
      logEvent(analytics, "game_over", { score: scoreVal });

      let name = localStorage.getItem("player_name") || "";
      const localBest = Number(localStorage.getItem("sb_best") || 0);
      if (!name || scoreVal >= localBest) {
        name = prompt("New high score! Enter your name for the leaderboard:") || "Anonymous";
        localStorage.setItem("player_name", name);
      }
      await submitScore(name, scoreVal);
    };

    // Live listeners for splash + game over leaderboards (Top 10 by bests)
    function renderEntriesTo(container, entries) {
      if (!container) return;
      if (!entries.length) {
        container.innerHTML = `<div class="lb-empty">No scores yet</div>`;
        return;
      }
      container.innerHTML = entries
        .map((e,i) => `<div class="${container.id==='leaderboardListGO'?'row':'lb-row'}"><span>${i+1}. ${e.name}</span><strong>${e.score}</strong></div>`)
        .join("");
    }

    function listenLeaderboards() {
      const bestsRef = ref(db, "bests");
      onValue(bestsRef, snap => {
        const listSplash = document.getElementById("leaderboardListSplash");
        const listGO     = document.getElementById("leaderboardListGO");
        if (!snap.exists()) {
          renderEntriesTo(listSplash, []);
          if (listGO) listGO.innerHTML = `<h3>üèÜ Leaderboard</h3><div class="row" style="justify-content:center; opacity:.8;">No scores yet</div>`;
          return;
        }
        const entries = Object.values(snap.val())
          .map(e => ({ name: e.name || "Anonymous", score: Number(e.bestScore || 0) }))
          .filter(e => Number.isFinite(e.score))
          .sort((a,b)=> b.score - a.score)
          .slice(0, 10);

        renderEntriesTo(listSplash, entries);

        if (listGO) {
          listGO.innerHTML = `<h3>üèÜ Leaderboard</h3>` + entries.map((e,i)=>`<div class="row"><span>${i+1}. ${e.name}</span><strong>${e.score}</strong></div>`).join("");
        }
      });
    }
    listenLeaderboards();
  </script>
</body>
</html>
