<!DOCTYPE html><html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Chess vs Computer — Easy • Medium • Hard</title>
  <style>
    :root{
      --bg: #0f1115;
      --panel: #151923;
      --accent: #7c5cff;
      --text: #f3f5f7;
      --muted: #9aa3ae;
      --good: #2ecc71;
      --bad: #e74c3c;
      --square-light: #eceff1;
      --square-dark: #78909c;
      --highlight: #ffd54f66;
      --lastmove: #7e57c249;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text); background:linear-gradient(180deg,#0f1115,#0b0d12);
      display:flex; align-items:center; justify-content:center; padding:24px;
    }
    .app{width: min(1150px, 100%); display:grid; grid-template-columns: 1fr 360px; gap:24px}
    @media (max-width:980px){ .app{ grid-template-columns: 1fr; } }.panel{background:var(--panel); border:1px solid #232a3a; border-radius:18px; box-shadow:0 10px 30px rgba(0,0,0,.35)}
.header{padding:14px 16px 0 16px}
h1{font-size:18px; margin:0; letter-spacing:.3px}
.sub{color:var(--muted); font-size:13px}

.toolbar{display:flex; flex-wrap:wrap; gap:10px; padding:12px 16px 16px 16px}
.toolbar select, .toolbar button{appearance:none; border:none; border-radius:12px; padding:10px 12px; background:#1c2232; color:var(--text); font-weight:600}
.toolbar button:hover{filter:brightness(1.08)}
.toolbar button:active{transform:translateY(1px)}
.pill{display:inline-flex; gap:8px; align-items:center; background:#1c2232; padding:8px 10px; border-radius:999px}
.pill label{font-size:12px; color:var(--muted)}
.pill select{padding:6px 8px; background:transparent}
.brand{display:flex; align-items:center; gap:10px}
.dot{width:8px; height:8px; border-radius:50%; background:var(--accent); box-shadow:0 0 0 4px #7c5cff33}

.board-wrap{display:flex; gap:20px; align-items:flex-start; justify-content:center; padding:16px}

.board{width:min(90vw, 640px); max-width:640px; aspect-ratio:1/1; border-radius:18px; overflow:hidden; position:relative; box-shadow:0 12px 40px rgba(0,0,0,.4)}
.grid{display:grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width:100%; height:100%}
.sq{display:flex; align-items:center; justify-content:center; font-size: clamp(28px, 7vw, 52px); user-select:none; cursor:pointer; position:relative}
.sq.light{background:var(--square-light)}
.sq.dark{background:var(--square-dark)}
.sq.selected{outline:3px solid var(--accent); outline-offset:-3px}
.sq .dot-move{position:absolute; width:22%; height:22%; border-radius:50%; background: #00000029}
.sq .ring-capture{position:absolute; width:84%; height:84%; border-radius:50%; border:5px solid rgba(0,0,0,.35)}
.sq.last{box-shadow: inset 0 0 0 9999px var(--lastmove)}
.sq.check{box-shadow: inset 0 0 0 9999px #e74c3c3a}

.coords{position:absolute; inset:0; pointer-events:none}
.coord-file{position:absolute; bottom:6px; right:8px; font-size:11px; color:#000000a0}
.coord-rank{position:absolute; top:6px; left:8px; font-size:11px; color:#ffffffb0}

.sidebar{padding:16px}
.card{background:#0f1320; border:1px solid #1f2637; border-radius:14px; padding:12px}
.card + .card{margin-top:12px}
.tag{display:inline-flex; align-items:center; gap:8px; font-size:12px; color:var(--muted)}
.status{display:flex; align-items:center; justify-content:space-between}
.log{max-height:340px; overflow:auto; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;}
.log table{width:100%; border-collapse:collapse}
.log td{padding:6px 8px; border-bottom:1px solid #1b2233; font-size:13px}
.log tr:nth-child(even){background:#0e1220}

.promo{position:fixed; inset:0; display:none; background:rgba(0,0,0,.6); align-items:center; justify-content:center}
.promo.active{display:flex}
.promo .modal{background:var(--panel); padding:18px; border-radius:14px; border:1px solid #232a3a; min-width:260px}
.promo h3{margin:0 0 12px 0}
.promo .choices{display:grid; grid-template-columns: repeat(4,1fr); gap:8px}
.promo .choices button{padding:10px; font-size:26px; border:none; border-radius:12px; background:#1c2232; color:var(--text); cursor:pointer}

.footer{padding:10px 16px 16px; color:var(--muted); font-size:12px}

  </style>
</head>
<body>
  <div class="app">
    <div class="panel">
      <div class="header">
        <div class="brand">
          <div class="dot"></div>
          <div>
            <h1>Chess vs Computer</h1>
            <div class="sub">Play as white or black • choose difficulty • undo • flip board</div>
          </div>
        </div>
      </div>
      <div class="toolbar">
        <div class="pill">
          <label>Difficulty</label>
          <select id="level">
            <option value="easy">Easy</option>
            <option value="medium" selected>Medium</option>
            <option value="hard">Hard</option>
          </select>
        </div>
        <div class="pill">
          <label>Play as</label>
          <select id="playAs">
            <option value="w" selected>White</option>
            <option value="b">Black</option>
          </select>
        </div>
        <button id="newBtn">New Game</button>
        <button id="undoBtn">Undo</button>
        <button id="flipBtn">Flip Board</button>
      </div>
      <div class="board-wrap">
        <div id="board" class="board">
          <div id="grid" class="grid"></div>
        </div>
      </div>
      <div class="footer">Tip: On Easy the computer plays fast and a bit random. Medium looks 2 plies ahead. Hard looks 3–4 plies with smarter move ordering.
      </div>
    </div>
    <div class="panel sidebar">
      <div class="card status">
        <div class="tag"><span>Turn:</span> <strong id="turnTag">White</strong></div>
        <div class="tag"><span>Result:</span> <strong id="resultTag">—</strong></div>
      </div>
      <div class="card log">
        <table id="movesTable"><tbody></tbody></table>
      </div>
      <div class="card">
        <div class="tag">Evaluation: <strong id="evalTag">0.00</strong></div>
      </div>
    </div>
  </div>  <!-- Promotion Modal -->  <div class="promo" id="promo">
    <div class="modal">
      <h3>Choose promotion</h3>
      <div class="choices">
        <button data-piece="q">♕</button>
        <button data-piece="r">♖</button>
        <button data-piece="b">♗</button>
        <button data-piece="n">♘</button>
      </div>
    </div>
  </div><script>
/********************
 * Minimal Chess Core
 * - Full legal move generation (incl. checks, castling, en passant, promotion)
 * - FEN load for start position
 * - Move history & undo
 ********************/
(function(){
  const START_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
  const FILES = ['a','b','c','d','e','f','g','h'];
  const RANKS = ['1','2','3','4','5','6','7','8'];

  function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
  function sqName(r,f){ return FILES[f] + RANKS[r]; }
  function parseSq(name){ return { f: FILES.indexOf(name[0]), r: RANKS.indexOf(name[1]) }; }

  class ChessCore{
    constructor(){ this.load(START_FEN); }

    load(fen){
      const [boardStr, turn, castling, ep, halfmove, fullmove] = fen.split(' ');
      this.board = [...Array(8)].map(()=>Array(8).fill(null));
      let r=7, f=0;
      for(const ch of boardStr){
        if(ch === '/') { r--; f=0; continue; }
        if(+ch>0){ f += +ch; continue; }
        const color = (ch === ch.toUpperCase()) ? 'w' : 'b';
        const type = ch.toLowerCase();
        this.board[r][f++] = {color,type};
      }
      this.turn = turn; // 'w' or 'b'
      this.castling = { wK: castling.includes('K'), wQ: castling.includes('Q'), bK: castling.includes('k'), bQ: castling.includes('q') };
      this.enPassant = (ep !== '-') ? parseSq(ep) : null;
      this.halfmove = +halfmove; this.fullmove = +fullmove;
      this.history = [];
    }

    inBounds(r,f){ return r>=0 && r<8 && f>=0 && f<8; }

    kingPos(color){
      for(let r=0;r<8;r++) for(let f=0;f<8;f++){
        const p=this.board[r][f]; if(p && p.color===color && p.type==='k') return {r,f};
      }
      return null;
    }

    isSquareAttacked(r,f,byColor){
      // Pawns
      const dir = (byColor==='w')?1:-1;
      for(const df of [-1,1]){
        const rr=r-dir, ff=f+df; // square from which a pawn could capture to (r,f)
        if(this.inBounds(rr,ff)){
          const p=this.board[rr][ff];
          if(p && p.color===byColor && p.type==='p') return true;
        }
      }
      // Knights
      const kMoves=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
      for(const [dr,df] of kMoves){
        const rr=r+dr, ff=f+df; if(!this.inBounds(rr,ff)) continue;
        const p=this.board[rr][ff]; if(p && p.color===byColor && p.type==='n') return true;
      }
      // Kings (adjacent)
      for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){
        if(dr===0 && df===0) continue; const rr=r+dr, ff=f+df; if(!this.inBounds(rr,ff)) continue;
        const p=this.board[rr][ff]; if(p && p.color===byColor && p.type==='k') return true;
      }
      // Sliding: bishops/queens (diagonals)
      const diag=[[1,1],[1,-1],[-1,1],[-1,-1]];
      for(const [dr,df] of diag){
        let rr=r+dr, ff=f+df; while(this.inBounds(rr,ff)){
          const p=this.board[rr][ff];
          if(p){ if(p.color===byColor && (p.type==='b'||p.type==='q')) return true; else break; }
          rr+=dr; ff+=df;
        }
      }
      // Sliding: rooks/queens (orthogonals)
      const ortho=[[1,0],[-1,0],[0,1],[0,-1]];
      for(const [dr,df] of ortho){
        let rr=r+dr, ff=f+df; while(this.inBounds(rr,ff)){
          const p=this.board[rr][ff];
          if(p){ if(p.color===byColor && (p.type==='r'||p.type==='q')) return true; else break; }
          rr+=dr; ff+=df;
        }
      }
      return false;
    }

    inCheck(color){
      const k=this.kingPos(color); if(!k) return false; return this.isSquareAttacked(k.r,k.f, color==='w'?'b':'w');
    }

    generateMoves(){
      const color=this.turn; const moves=[];
      for(let r=0;r<8;r++) for(let f=0;f<8;f++){
        const p=this.board[r][f]; if(!p||p.color!==color) continue;
        this._pieceMoves(r,f,p,moves);
      }
      // filter illegal (leave king in check)
      const legal=[];
      for(const m of moves){ this._make(m); const ok=!this.inCheck(color); this._unmake(); if(ok) legal.push(m); }
      return legal;
    }

    _pushMove(moves, fromR,fromF, toR,toF, opts={}){
      const m={from:{r:fromR,f:fromF}, to:{r:toR,f:toF}, promotion:opts.promotion||null, capture:null, flags:opts.flags||''};
      const dest=this.board[toR][toF]; if(dest) m.capture=clone(dest);
      moves.push(m);
    }

    _pieceMoves(r,f,p,moves){
      if(p.type==='p') return this._pawnMoves(r,f,p,moves);
      if(p.type==='n') return this._knightMoves(r,f,p,moves);
      if(p.type==='b') return this._slideMoves(r,f,p,moves, [[1,1],[1,-1],[-1,1],[-1,-1]]);
      if(p.type==='r') return this._slideMoves(r,f,p,moves, [[1,0],[-1,0],[0,1],[0,-1]]);
      if(p.type==='q') return this._slideMoves(r,f,p,moves, [[1,1],[1,-1],[-1,1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]]);
      if(p.type==='k') return this._kingMoves(r,f,p,moves);
    }

    _pawnMoves(r,f,p,moves){
      const dir = (p.color==='w')?1:-1; const startRank=(p.color==='w')?1:6; const promoRank=(p.color==='w')?7:0;
      const oneR=r+dir;
      // advance
      if(this.inBounds(oneR,f) && !this.board[oneR][f]){
        if(oneR===promoRank){ for(const pr of ['q','r','b','n']) this._pushMove(moves,r,f,oneR,f,{promotion:pr}); }
        else this._pushMove(moves,r,f,oneR,f,{});
        // 2-step
        if(r===startRank){ const twoR=r+2*dir; if(this.inBounds(twoR,f)&&!this.board[twoR][f]) this._pushMove(moves,r,f,twoR,f,{flags:'P2'}); }
      }
      // captures
      for(const df of [-1,1]){
        const cf=f+df, cr=r+dir; if(!this.inBounds(cr,cf)) continue;
        const t=this.board[cr][cf];
        if(t && t.color!==p.color){
          if(cr===promoRank){ for(const pr of ['q','r','b','n']) this._pushMove(moves,r,f,cr,cf,{promotion:pr}); }
          else this._pushMove(moves,r,f,cr,cf,{});
        }
      }
      // en passant
      if(this.enPassant){
        for(const df of [-1,1]){
          const cf=f+df, cr=r+dir; if(!this.inBounds(cr,cf)) continue;
          if(this.enPassant.r===cr && this.enPassant.f===cf){ this._pushMove(moves,r,f,cr,cf,{flags:'EP'}); }
        }
      }
    }

    _knightMoves(r,f,p,moves){
      const deltas=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
      for(const [dr,df] of deltas){ const rr=r+dr, ff=f+df; if(!this.inBounds(rr,ff)) continue; const t=this.board[rr][ff]; if(!t||t.color!==p.color) this._pushMove(moves,r,f,rr,ff,{}); }
    }

    _slideMoves(r,f,p,moves,dirs){
      for(const [dr,df] of dirs){
        let rr=r+dr, ff=f+df; while(this.inBounds(rr,ff)){
          const t=this.board[rr][ff];
          if(!t){ this._pushMove(moves,r,f,rr,ff,{}); }
          else { if(t.color!==p.color) this._pushMove(moves,r,f,rr,ff,{}); break; }
          rr+=dr; ff+=df;
        }
      }
    }

    _kingMoves(r,f,p,moves){
      for(let dr=-1;dr<=1;dr++) for(let df=-1;df<=1;df++){
        if(!dr&&!df) continue; const rr=r+dr, ff=f+df; if(!this.inBounds(rr,ff)) continue; const t=this.board[rr][ff]; if(!t||t.color!==p.color) this._pushMove(moves,r,f,rr,ff,{});
      }
      // Castling
      if(this.inCheck(p.color)) return; // can't castle out of check
      const rank = (p.color==='w')?0:7;
      if(r!==rank||f!==4) return; // king must be on starting square
      if(p.color==='w'){
        if(this.castling.wK && !this.board[0][5] && !this.board[0][6] && !this.isSquareAttacked(0,5,'b') && !this.isSquareAttacked(0,6,'b')) this._pushMove(moves,r,f,0,6,{flags:'CK'});
        if(this.castling.wQ && !this.board[0][1] && !this.board[0][2] && !this.board[0][3] && !this.isSquareAttacked(0,3,'b') && !this.isSquareAttacked(0,2,'b')) this._pushMove(moves,r,f,0,2,{flags:'CQ'});
      } else {
        if(this.castling.bK && !this.board[7][5] && !this.board[7][6] && !this.isSquareAttacked(7,5,'w') && !this.isSquareAttacked(7,6,'w')) this._pushMove(moves,r,f,7,6,{flags:'CK'});
        if(this.castling.bQ && !this.board[7][1] && !this.board[7][2] && !this.board[7][3] && !this.isSquareAttacked(7,3,'w') && !this.isSquareAttacked(7,2,'w')) this._pushMove(moves,r,f,7,2,{flags:'CQ'});
      }
    }

    _make(m){
      // Save snapshot
      const snap={board:clone(this.board), turn:this.turn, castling:clone(this.castling), enPassant: this.enPassant?{...this.enPassant}:null, halfmove:this.halfmove, fullmove:this.fullmove, move:m};
      this.history.push(snap);
      const fromP = this.board[m.from.r][m.from.f];
      const toP   = this.board[m.to.r][m.to.f];
      // En passant capture removal
      if(m.flags==='EP'){
        const dir = (fromP.color==='w')?1:-1; // pawn moved up (white) or down
        const capR = m.to.r - dir; const capF = m.to.f;
        this.board[capR][capF] = null;
      }
      // Move piece
      this.board[m.to.r][m.to.f] = clone(fromP);
      this.board[m.from.r][m.from.f] = null;
      // Promotion
      if(m.promotion){ this.board[m.to.r][m.to.f].type = m.promotion; }
      // Castling rook move
      if(m.flags==='CK'){ // king-side
        const r = (fromP.color==='w')?0:7; this.board[r][5]=this.board[r][7]; this.board[r][7]=null;
      } else if(m.flags==='CQ'){
        const r = (fromP.color==='w')?0:7; this.board[r][3]=this.board[r][0]; this.board[r][0]=null;
      }
      // Update castling rights
      const movePiece = fromP.type + fromP.color;
      if(movePiece==='kw'){ this.castling.wK=false; this.castling.wQ=false; }
      if(movePiece==='kb'){ this.castling.bK=false; this.castling.bQ=false; }
      if(movePiece==='rw' && m.from.r===0 && m.from.f===0) this.castling.wQ=false;
      if(movePiece==='rw' && m.from.r===0 && m.from.f===7) this.castling.wK=false;
      if(movePiece==='rb' && m.from.r===7 && m.from.f===0) this.castling.bQ=false;
      if(movePiece==='rb' && m.from.r===7 && m.from.f===7) this.castling.bK=false;
      // If rook captured, update castling rights
      if(toP && toP.type==='r' && toP.color==='w'){
        if(m.to.r===0&&m.to.f===0) this.castling.wQ=false;
        if(m.to.r===0&&m.to.f===7) this.castling.wK=false;
      }
      if(toP && toP.type==='r' && toP.color==='b'){
        if(m.to.r===7&&m.to.f===0) this.castling.bQ=false;
        if(m.to.r===7&&m.to.f===7) this.castling.bK=false;
      }
      // En passant target update
      this.enPassant = null;
      if(fromP.type==='p' && Math.abs(m.to.r - m.from.r)===2){
        const midR = (m.to.r + m.from.r)/2; this.enPassant = {r:midR, f:m.from.f};
      }
      // Halfmove clock
      if(fromP.type==='p' || toP) this.halfmove=0; else this.halfmove++;
      // Fullmove
      if(this.turn==='b') this.fullmove++;
      // Switch turn
      this.turn = (this.turn==='w') ? 'b' : 'w';
    }

    _unmake(){
      const s=this.history.pop();
      this.board = s.board; this.turn = s.turn; this.castling = s.castling; this.enPassant = s.enPassant; this.halfmove = s.halfmove; this.fullmove = s.fullmove;
    }

    move(m){ this._make(m); return m; }
    undo(){ if(!this.history.length) return null; const last=this.history[this.history.length-1]; this.board=last.board; this.turn=last.turn; this.castling=last.castling; this.enPassant=last.enPassant; this.halfmove=last.halfmove; this.fullmove=last.fullmove; this.history.pop(); return last.move; }

    gameOver(){
      const legal=this.generateMoves();
      if(legal.length===0){ return this.inCheck(this.turn) ? (this.turn==='w'?'Black wins (checkmate)':'White wins (checkmate)') : 'Draw (stalemate)'; }
      if(this.halfmove>=100) return 'Draw (50-move rule)';
      // Repetition could be tracked, omitted for brevity
      return null;
    }

    fen(){
      let s=''; for(let r=7;r>=0;r--){ let empty=0; for(let f=0;f<8;f++){ const p=this.board[r][f]; if(!p){ empty++; continue; } if(empty>0){ s+=empty; empty=0; } const ch = p.type.toUpperCase(); s += (p.color==='w')?ch:ch.toLowerCase(); } if(empty>0) s+=empty; if(r>0) s+='/'; }
      let cstr = (this.castling.wK?'K':'') + (this.castling.wQ?'Q':'') + (this.castling.bK?'k':'') + (this.castling.bQ?'q':''); if(!cstr) cstr='-';
      let ep='-'; if(this.enPassant) ep=sqName(this.enPassant.r,this.enPassant.f);
      return s + ' ' + this.turn + ' ' + cstr + ' ' + ep + ' ' + this.halfmove + ' ' + this.fullmove;
    }
  }

  window.__ChessCore = ChessCore;
  window.__sqName = sqName;
})();
</script><script>
/********************
 * Simple AI (minimax + alpha-beta + piece-square evaluation)
 ********************/
(function(){
  const VALUES = { p:100, n:320, b:330, r:500, q:900, k:20000 };
  // Piece-square tables (white); black uses mirrored ranks
  const PST = {
    p:[0,0,0,0,0,0,0,0, 50,50,50,50,50,50,50,50, 10,10,20,30,30,20,10,10, 5,5,10,25,25,10,5,5, 0,0,0,20,20,0,0,0, 5,-5,-10,0,0,-10,-5,5, 5,10,10,-20,-20,10,10,5, 0,0,0,0,0,0,0,0],
    n:[-50,-40,-30,-30,-30,-30,-40,-50, -40,-20,0,0,0,0,-20,-40, -30,0,10,15,15,10,0,-30, -30,5,15,20,20,15,5,-30, -30,0,15,20,20,15,0,-30, -30,5,10,15,15,10,5,-30, -40,-20,0,5,5,0,-20,-40, -50,-40,-30,-30,-30,-30,-40,-50],
    b:[-20,-10,-10,-10,-10,-10,-10,-20, -10,0,0,0,0,0,0,-10, -10,0,5,10,10,5,0,-10, -10,5,5,10,10,5,5,-10, -10,0,10,10,10,10,0,-10, -10,10,10,10,10,10,10,-10, -10,5,0,0,0,0,5,-10, -20,-10,-10,-10,-10,-10,-10,-20],
    r:[0,0,0,5,5,0,0,0, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, -5,0,0,0,0,0,0,-5, 5,10,10,10,10,10,10,5, 0,0,0,0,0,0,0,0],
    q:[-20,-10,-10,-5,-5,-10,-10,-20, -10,0,0,0,0,0,0,-10, -10,0,5,5,5,5,0,-10, -5,0,5,5,5,5,0,-5, 0,0,5,5,5,5,0,-5, -10,0,5,5,5,5,0,-10, -10,0,0,0,0,0,0,-10, -20,-10,-10,-5,-5,-10,-10,-20],
    k:[-30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -30,-40,-40,-50,-50,-40,-40,-30, -20,-30,-30,-40,-40,-30,-30,-20, -10,-20,-20,-20,-20,-20,-20,-10, 20,20,0,0,0,0,20,20, 20,30,10,0,0,10,30,20]
  };

  function evalBoard(chess){
    let score=0;
    for(let r=0;r<8;r++) for(let f=0;f<8;f++){
      const p=chess.board[r][f]; if(!p) continue; const s=(p.color==='w')?1:-1; const idx = p.color==='w'? (r*8+f) : ((7-r)*8+f);
      score += s * (VALUES[p.type] + (PST[p.type]? PST[p.type][idx]:0));
    }
    // Mobility bonus
    const turn=chess.turn;
    const myMoves = chess.generateMoves().length;
    chess.turn = (turn==='w')?'b':'w';
    const oppMoves = chess.generateMoves().length;
    chess.turn = turn;
    score += 2*(myMoves - oppMoves);
    return score;
  }

  function orderMoves(chess, moves){
    // MVV-LVA-ish: captures first, then promotions, castles, quiet
    return moves.map(m=>{
      const fromP = chess.board[m.from.r][m.from.f];
      const toP   = m.capture;
      let score = 0;
      if(toP) score += 10*VALUES[toP.type] - VALUES[fromP.type];
      if(m.promotion) score += VALUES[m.promotion];
      if(m.flags==='CK' || m.flags==='CQ') score += 20;
      return {m,score};
    }).sort((a,b)=>b.score-a.score).map(x=>x.m);
  }

  function minimax(chess, depth, alpha, beta, maximizing){
    const over = chess.gameOver();
    if(over){
      if(over.includes('wins')) return (maximizing? -1 : 1)*100000; // mate
      return 0; // draw
    }
    if(depth===0) return evalBoard(chess);

    const moves = orderMoves(chess, chess.generateMoves());
    if(maximizing){
      let value = -Infinity;
      for(const m of moves){ chess._make(m); value = Math.max(value, minimax(chess, depth-1, alpha, beta, false)); chess._unmake(); alpha = Math.max(alpha, value); if(alpha>=beta) break; }
      return value;
    } else {
      let value = +Infinity;
      for(const m of moves){ chess._make(m); value = Math.min(value, minimax(chess, depth-1, alpha, beta, true)); chess._unmake(); beta = Math.min(beta, value); if(alpha>=beta) break; }
      return value;
    }
  }

  function pickMove(chess, level){
    const moves = orderMoves(chess, chess.generateMoves());
    if(moves.length===0) return null;
    if(level==='easy'){
      // 60% best-of-1, 40% random
      if(Math.random()<0.4) return moves[Math.floor(Math.random()*moves.length)];
      let best=null, bestScore=-Infinity; for(const m of moves){ chess._make(m); const s=-evalBoard(chess); chess._unmake(); if(s>bestScore){bestScore=s; best=m;} } return best;
    }
    const depth = (level==='medium')? 2 : 3; // hard = 3 (fast); bump to 4 if you want stronger and accept slower play
    let best=null, bestScore=-Infinity;
    for(const m of moves){
      chess._make(m);
      const score = -minimax(chess, depth-1, -Infinity, +Infinity, false);
      chess._unmake();
      if(score>bestScore){ bestScore=score; best=m; }
    }
    return best;
  }

  window.__AI = { pickMove, evalBoard };
})();
</script><script>
/********************
 * UI / Controller
 ********************/
(function(){
  const Chess = window.__ChessCore; const AI = window.__AI; const sqName = window.__sqName;
  const grid = document.getElementById('grid');
  const turnTag = document.getElementById('turnTag');
  const resultTag = document.getElementById('resultTag');
  const evalTag = document.getElementById('evalTag');
  const levelSel = document.getElementById('level');
  const playAsSel = document.getElementById('playAs');
  const newBtn = document.getElementById('newBtn');
  const undoBtn = document.getElementById('undoBtn');
  const flipBtn = document.getElementById('flipBtn');
  const promo = document.getElementById('promo');

  let game = new Chess();
  let orientation = 'w';
  let human = 'w';
  let selected = null; // {r,f}
  let legalForSelected = [];
  let lastMove = null; // {from,to}

  function unicodeFor(p){
    const mapW = {k:'\u2654', q:'\u2655', r:'\u2656', b:'\u2657', n:'\u2658', p:'\u2659'};
    const mapB = {k:'\u265A', q:'\u265B', r:'\u265C', b:'\u265D', n:'\u265E', p:'\u265F'};
    return (p.color==='w'?mapW:mapB)[p.type];
  }

  function buildBoard(){
    grid.innerHTML='';
    const ranks = orientation==='w' ? [7,6,5,4,3,2,1,0] : [0,1,2,3,4,5,6,7];
    const files = orientation==='w' ? [0,1,2,3,4,5,6,7] : [7,6,5,4,3,2,1,0];
    for(const r of ranks){
      for(const f of files){
        const sq = document.createElement('div'); sq.className='sq ' + (((r+f)%2===0)?'light':'dark');
        sq.dataset.r=r; sq.dataset.f=f; sq.dataset.square=sqName(r,f);
        if(lastMove && ((lastMove.from.r===r && lastMove.from.f===f) || (lastMove.to.r===r && lastMove.to.f===f))) sq.classList.add('last');
        const p=game.board[r][f]; if(p){ sq.textContent=unicodeFor(p); }
        // tiny coords on a1/h8
        if((r===0&&f===0)||(r===7&&f===7)){
          const coordFile=document.createElement('div'); coordFile.className='coord-file'; coordFile.textContent=FILES[f];
          const coordRank=document.createElement('div'); coordRank.className='coord-rank'; coordRank.textContent=RANKS[r];
          const wrap=document.createElement('div'); wrap.className='coords'; wrap.append(coordFile,coordRank); sq.appendChild(wrap);
        }
        grid.appendChild(sq);
      }
    }
    highlightCheck();
  }

  // Helpers to map DOM squares
  function getSqEl(r,f){ return grid.querySelector(`.sq[data-r="${r}"][data-f="${f}"]`); }

  function setTurnTags(){ turnTag.textContent = (game.turn==='w')? 'White' : 'Black'; }

  function updateEval(){ evalTag.textContent = (AI.evalBoard(game)/100).toFixed(2); }

  function clearHighlights(){ grid.querySelectorAll('.sq').forEach(el=>{ el.classList.remove('selected'); el.querySelector('.dot-move')?.remove(); el.querySelector('.ring-capture')?.remove(); }); }

  function highlightMoves(moves){
    for(const m of moves){ const el=getSqEl(m.to.r,m.to.f); if(!el) continue; if(m.capture) { const ring=document.createElement('div'); ring.className='ring-capture'; el.appendChild(ring);} else { const dot=document.createElement('div'); dot.className='dot-move'; el.appendChild(dot);} }
  }

  function highlightCheck(){
    // mark king if in check
    const color=game.turn; if(game.inCheck(color)){ const k=game.kingPos(color); const el=getSqEl(k.r,k.f); if(el) el.classList.add('check'); }
  }

  function legalMovesFrom(r,f){
    const all=game.generateMoves();
    return all.filter(m=> m.from.r===r && m.from.f===f);
  }

  function moveToNotation(m){
    const from = sqName(m.from.r,m.from.f), to=sqName(m.to.r,m.to.f);
    let s=from+"→"+to; if(m.promotion) s += "="+ m.promotion.toUpperCase(); if(m.flags==='CK') s='O-O'; if(m.flags==='CQ') s='O-O-O'; if(m.capture) s = from+"x"+to + (m.promotion?"="+m.promotion.toUpperCase():""); return s;
  }

  function pushLog(m){
    const tbody=document.querySelector('#movesTable tbody');
    const tr=document.createElement('tr');
    const td1=document.createElement('td'); td1.textContent = game.turn==='b' ? Math.ceil(game.fullmove-0.5) : game.fullmove; // display prior fullmove
    const td2=document.createElement('td'); td2.textContent = moveToNotation(m);
    tr.append(td1,td2); tbody.appendChild(tr); tbody.parentElement.scrollTop = tbody.parentElement.scrollHeight;
  }

  function refresh(){ buildBoard(); setTurnTags(); updateEval(); }

  function maybeAIMove(){
    const over = game.gameOver(); if(over){ resultTag.textContent = over; return; }
    if(game.turn !== (human==='w'?'b':'w')) return; // AI's color
    setTimeout(()=>{
      const m = AI.pickMove(game, levelSel.value);
      if(!m){ resultTag.textContent = game.inCheck(game.turn)? ((game.turn==='w')?'Black wins (checkmate)':'White wins (checkmate)') : 'Draw'; return; }
      lastMove = {from:{...m.from},to:{...m.to}};
      game.move(m);
      pushLog(m);
      refresh();
      maybeAIMove();
    }, 120);
  }

  function onSquareClick(e){
    const el = e.target.closest('.sq'); if(!el) return;
    const r=+el.dataset.r, f=+el.dataset.f;
    const piece = game.board[r][f];
    // If it's player's turn and clicked own piece: select
    if(game.turn===human && piece && piece.color===human){
      clearHighlights(); selected={r,f}; legalForSelected = legalMovesFrom(r,f);
      el.classList.add('selected'); highlightMoves(legalForSelected); return;
    }
    // If we have a selection and clicked a legal destination
    if(selected){
      const legal = legalForSelected.find(m=> m.to.r===r && m.to.f===f);
      if(legal){
        // Handle promotion ask
        const isPromo = !!legal.promotion || (game.board[selected.r][selected.f].type==='p' && (r===7||r===0));
        if(isPromo){
          promo.classList.add('active');
          const choose=(pieceCode)=>{ promo.classList.remove('active'); document.querySelectorAll('#promo .choices button').forEach(b=>b.removeEventListener('click', handler));
            const move = {...legal, promotion:pieceCode};
            lastMove = {from:{...move.from},to:{...move.to}}; game.move(move); pushLog(move); selected=null; legalForSelected=[]; clearHighlights(); refresh(); maybeAIMove(); };
          const handler=(ev)=> choose(ev.currentTarget.dataset.piece);
          document.querySelectorAll('#promo .choices button').forEach(btn=> btn.addEventListener('click', handler));
          return;
        }
        lastMove = {from:{...legal.from},to:{...legal.to}};
        game.move(legal); pushLog(legal); selected=null; legalForSelected=[]; clearHighlights(); refresh(); maybeAIMove(); return;
      }
      // otherwise clear selection
      selected=null; legalForSelected=[]; clearHighlights();
    }
  }

  function newGame(){ game = new Chess(); lastMove=null; resultTag.textContent='—'; selected=null; legalForSelected=[]; clearHighlights();
    // If human chooses black, let AI start
    if(human==='b'){ refresh(); maybeAIMove(); } else refresh();
  }

  function undoMove(){
    // Undo last full move: if last move was by AI, undo once; also undo human's move
    if(game.history.length===0) return;
    game.undo();
    if(game.turn!==human && game.history.length>0) game.undo();
    lastMove=null; resultTag.textContent='—'; refresh();
  }

  function flip(){ orientation = (orientation==='w')?'b':'w'; buildBoard(); }

  // Event bindings
  grid.addEventListener('click', onSquareClick);
  newBtn.addEventListener('click', newGame);
  undoBtn.addEventListener('click', undoMove);
  flipBtn.addEventListener('click', flip);
  playAsSel.addEventListener('change', (e)=>{ human=e.target.value; newGame(); });

  // Init
  refresh();
})();
</script></body>
</html>
