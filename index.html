<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Shaebae’s Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      background: #111;
      color: #fff;
      font-family: 'Press Start 2P', monospace;
      overflow: hidden;
    }
    canvas {
      display: block;
      margin: auto;
      background: linear-gradient(#6ec6ff, #b3e5fc);
      touch-action: none;
    }
    #hud, #gameover, #splash {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      flex-direction: column;
      text-align: center;
      font-size: 18px;
      pointer-events: none;
    }
    #gameover, #splash {
      background: rgba(0,0,0,0.5);
      color: #fff;
      display: none;
    }
    button {
      background: #fff;
      color: #000;
      border: none;
      padding: 10px 20px;
      border-radius: 8px;
      font-weight: bold;
      cursor: pointer;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <canvas id="game" width="360" height="640"></canvas>
  <div id="hud">
    <div id="score">0</div>
  </div>
  <div id="splash">
    <h1>Shaebae’s Game ❤️</h1>
    <p>Tap or Press Space to Start</p>
  </div>
  <div id="gameover">
    <h2>Game Over</h2>
    <p id="final">Score: 0</p>
    <button id="again">Play Again</button>
  </div>

  <script>
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const splash = document.getElementById("splash");
  const gameover = document.getElementById("gameover");
  const scoreEl = document.getElementById("score");
  const finalEl = document.getElementById("final");
  const again = document.getElementById("again");

  let bird, pipes, gravity, flap, speed, gap, score, best = 0, gameState = "splash";

  const W = canvas.width, H = canvas.height;
  const GROUND = H - 112;

  function resetGame() {
    bird = { x: 80, y: 200, vy: 0, r: 12 };
    pipes = [];
    gravity = 1800;
    flap = -420;
    speed = 180;
    gap = 160;
    score = 0;
    scoreEl.textContent = 0;
  }

  function startGame() {
    splash.style.display = "none";
    gameover.style.display = "none";
    resetGame();
    gameState = "running";
  }

  function endGame() {
    gameState = "over";
    playHit();
    setTimeout(() => {
      triggerJumpScare();
    }, 600);
  }

  function triggerJumpScare() {
    // full-screen scary face and loud scream
    const overlay = document.createElement("div");
    overlay.style.position = "fixed";
    overlay.style.inset = "0";
    overlay.style.background = "black";
    overlay.style.display = "flex";
    overlay.style.justifyContent = "center";
    overlay.style.alignItems = "center";
    overlay.style.zIndex = "9999";
    document.body.appendChild(overlay);

    const img = document.createElement("img");
    img.src = "https://upload.wikimedia.org/wikipedia/commons/3/3e/Scary_face.png";
    img.style.width = "100%";
    img.style.height = "100%";
    img.style.objectFit = "cover";
    overlay.appendChild(img);

    const audio = new Audio("https://actions.google.com/sounds/v1/horror/horror_scream.ogg");
    audio.volume = 1.0;
    audio.play();

    setTimeout(() => {
      document.body.removeChild(overlay);
      showGameOver();
    }, 1500);
  }

  function showGameOver() {
    finalEl.textContent = "Score: " + score;
    gameover.style.display = "flex";
  }

  function playFlap() {
    const audio = new Audio("https://actions.google.com/sounds/v1/cartoon/cartoon_boing.ogg");
    audio.volume = 0.3;
    audio.play();
  }

  function playPoint() {
    const audio = new Audio("https://actions.google.com/sounds/v1/cartoon/clang_and_wobble.ogg");
    audio.volume = 0.2;
    audio.play();
  }

  function playHit() {
    const audio = new Audio("https://actions.google.com/sounds/v1/horror/monster_growl.ogg");
    audio.volume = 0.4;
    audio.play();
  }

  function flapBird() {
    if (gameState === "splash") {
      startGame();
    }
    if (gameState === "running") {
      bird.vy = flap;
      playFlap();
    }
  }

  canvas.addEventListener("mousedown", flapBird);
  canvas.addEventListener("touchstart", flapBird);
  document.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "ArrowUp" || e.code === "KeyW") flapBird();
  });

  again.onclick = () => {
    splash.style.display = "flex";
    gameover.style.display = "none";
    gameState = "splash";
  };

  function update(dt) {
    if (gameState !== "running") return;

    bird.vy += gravity * dt;
    bird.y += bird.vy * dt;
    if (bird.vy > 900) bird.vy = 900;

    if (bird.y + bird.r >= GROUND) {
      bird.y = GROUND - bird.r;
      endGame();
    }

    for (let i = pipes.length - 1; i >= 0; i--) {
      const p = pipes[i];
      p.x -= speed * dt;
      if (p.x + 52 < 0) pipes.splice(i, 1);
      if (!p.scored && p.x + 52 < bird.x) {
        p.scored = true;
        score++;
        scoreEl.textContent = score;
        playPoint();
      }
      if (checkCollision(bird, p)) {
        endGame();
      }
    }

    if (pipes.length === 0 || W - pipes[pipes.length - 1].x > 180) {
      const gapY = Math.random() * (H - gap - 240) + 120;
      pipes.push({ x: W, top: gapY - 320, bottom: gapY + gap, scored: false });
    }
  }

  function checkCollision(b, p) {
    return (
      (b.x + b.r > p.x && b.x - b.r < p.x + 52 &&
        (b.y - b.r < p.top + 320 || b.y + b.r > p.bottom))
    );
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);

    ctx.fillStyle = "#6ec6ff";
    ctx.fillRect(0, 0, W, H);

    for (const p of pipes) {
      ctx.fillStyle = "#228B22";
      ctx.fillRect(p.x, p.top, 52, 320);
      ctx.fillRect(p.x, p.bottom, 52, H - p.bottom);
    }

    ctx.fillStyle = "#deb887";
    ctx.fillRect(0, GROUND, W, 112);

    ctx.save();
    ctx.translate(bird.x, bird.y);
    ctx.rotate(Math.min((bird.vy / 900) * Math.PI / 2, Math.PI / 2));
    ctx.fillStyle = "#ffeb3b";
    ctx.beginPath();
    ctx.arc(0, 0, bird.r, 0, Math.PI * 2);
    ctx.fill();
    ctx.restore();
  }

  let last = 0;
  function loop(ts) {
    const dt = Math.min((ts - last) / 1000, 0.02);
    last = ts;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }
  resetGame();
  splash.style.display = "flex";
  requestAnimationFrame(loop);
  </script>
</body>
</html>
